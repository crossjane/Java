
public class Ch02 {

	public static void main(String[] args) {
		// 01 진수
		// 진수(진법) : 정수를 표현할 때 사용되는 수 표현방법.
		// JAVA는 기본적으로 10진수를 사용, 정수 리터럴을 작성할 때는 10진수가 기본적으로 사용됨.
		
		// 02 서식문자를 사용한 진수 표현법
//		System.out.println("--------------- 진수와 서식문자 예제 ---------------");
//		// 10진수로 변환
//		System.out.printf("10진수 : %d\n", 0b10101101);		// 0b		: 2진수
//		System.out.printf("10진수 : %d\n", 173);				// 			: 10진수
//		System.out.printf("10진수 : %d\n", 0255);				// 0		: 8진수
//		System.out.printf("10진수 : %d\n", 0xAD);				// 0x		: 16진수
//		System.out.println();
//		
//		
//		// 8진수로 변환
//		System.out.printf("8진수 : %o\n", 0b10101101);		// 0b		: 2진수
//		System.out.printf("8진수 : %o\n", 173);				// 			: 10진수
//		System.out.printf("8진수 : %o\n", 0255);				// 0		: 8진수
//		System.out.printf("8진수 : %o\n", 0xAD);				// 0x		: 16진수
//		System.out.println();
//
//		
//		// 16진수로 변환
//		System.out.printf("16진수 : %x\n", 0b10101101);		// 0b		: 2진수
//		System.out.printf("16진수 : %x\n", 173);				// 			: 10진수
//		System.out.printf("16진수 : %x\n", 0255);				// 0		: 8진수
//		System.out.printf("16진수 : %x\n", 0xAD);				// 0x		: 16진수
//		System.out.println();
		
		// ==> 컴퓨터는 내부적으로 모든 값을 이진(binary) 데이터로 저장하고 있음
		//		우리가 보는 것은 다양한 진법의 리터럴을 통해 그 값을 해석한 것 뿐임. == 형식 지정자(서식문자)에 맞게 표현한 것 뿐임.
		
		
		
		// 03 이진 데이터(2진수)의 양수 표현 방식
		
		// 컴퓨터는 10진수 데이터를 2진수 데이터로 변환하여 저장되는데
		// 이때 2진수로 변환된 데이터 하나를 담는 최소 공간단위 == 비트(bit)
		
		// ###
		// 1 byte == 8 bit
		// ###
		
		// 2진수를 10진수로 변환할 때 계산하는 방법
		// 1	1	1	1	1	1	1	1
		// 128	64	32	16	8	4	2	1 ==> 255
		
		// 1byte ==> 0 - 255
		//			-128 - 127
		
		// 10진수	->		2진수
		// 0		->		0			1비트가 사용됨.
		// 1		->		1			1비트가 사용됨.
		// 2		->		10			2비트가 사용됨.
		// 3		->		11			2비트가 사용됨.
		// 4		->		100			3비트가 사용됨.
		// 5		->		101			3비트가 사용됨.
		// 8		->		1000		4비트가 사용됨.
		// 31		->		11111		5비트가 사용됨.
		// 44		->		101100		6비트가 사용됨.
		// 112		->		1110000		7비트가 사용됨.
		// 255		->		11111111	8비트가 사용됨.
		// 256		->		100000000	9비트가 사용됨.
		
		// 10진수를 2진수로 변환하는 문제!
		// 
		// 10		->		???
		// 12		->		???
		// 20		->		???
		// 59		->		???
		// 72		->		???
		// 42		->		???
		// 160		->		??? 
		
		
		// 2진수를 10진수로 변환하는 문제!
		// 
		// 11000001	->		???
		// 01011101	->		???
		// 00001011	->		???
		// 10101110 ->		???
		// 11101101 ->		???
		// 10111010 ->		???
		// 11010101 ->		???
		// 01110101 ->		???
		
		
		
		
		
		
		
		
		// 10		->		1010
		// 12		->		1100
		// 20		->		10100
		// 59		->		111011
		// 72		->		1001000
		// 42		->		101010
		// 160		->		10100000
		
		
		
		
		// 11000001	->		193
		// 01011101	->		93
		// 00001011	->		11
		// 10101110 ->		174
		// 11101101 ->		237
		// 10111010 ->		186
		// 11010101 ->		213
		// 01110101 ->		117
		
		
		
		
		
		
		// 04 이진 데이터(2진수)의 음수 표현 방식

		// CPU는 가산기(가산회로)에 의해서 데이터에 대한 덧셈연산을 할 수 있다? O
		// CPU는 감산기(감산회로)에 의해서 데이터에 대한 뺄셈연산을 할 수 있다? X
		// CPU는 애초에 가연산에 특화되어 있는 명령 처리 장치이다.
		
		// 3가지가 있음.
		
		
				// 1. 부호가 있는 절대치			: 우리가 딱 봤을 때 알 수 있도록 만든 표현 방식
//					  Ex) +2			-->			0 000 0010
//						  +1			-->			0 000 0001
//						  +0			-->			0 000 0000		
				// 	
//						  -0			-->			1 000 0000
//						  -1			-->			1 000 0001
//						  -2			-->			1 000 0010
				// 
				// 2. 1의 보수
				// 3. 2의 보수
		
		
		// 8비트공간에 음수를 저장할 수 있다.
		// 8비트에서 부호를 지원한다면 제일 앞 비트는 부호 비트이다! 
		// 
		// (Signed, Unsigned) : 자료형 가서 설명 예정. 
		// Signed	:	부호 O	즉 음수, 0, 양수 사용
		// Unsigned	:	부호 X	즉		 0, 양수 사용
		
		
		
		// 
		// 부호비트가 0이면 양수 <-------------------> 1이면 음수
		
		// 컴퓨터의 뺄셈 처리는 '보수' 개념을 이용해서 음수를 양수화 하여
		// 계산하는데 이는 뺄셈 결과와 동일한 결과가 나옴.
		
		// A - B는 A + (B의 보수)로 바꾸어 계산함.
		
		
		
		
		
		
		// ## 보수의 개념 ##
		
		// 보수란? : 각 자리의 숫자의 합이 일정한 수가 되게 하는 수
		// 즉 어느 수에 대한 반전, 뒤집는 개념


		//N진수라면 보수가 두가지 존재함.
		//1. N - 1의 보수
		//2. N의 보수
		
		//Ex) 10진수에는 10의 보수와 9의 보수가 존재
		//   2진수에는  2의 보수와 1의 보수가 존재


		//1에 대한 10의 보수는 9
		//2에 대한 10의 보수는 8
		//3에 대한 10의 보수는 7
		
		
		//3에 대한 9의 보수는 6
		//5에 대한 9의 보수는 4
		//---------------------------------
		//일정 수를 기준으로 반대되는 수 == 보수
		
		//33에 대한 9의 보수는 66					--> 6(9-3) 6(9-3) 
		//33에 대한 10의 보수는 67				--> 66 + 1
		//---------------------------------
		//어? 여기서 알 수 있는 것은 
		//n의 보수 == n-1의 보수에서 1을 더했을 때 '자릿수가 올라가는 수'
		
		
		
		// 1) 1의 보수 구하는 법
		// 
		//  1의 보수 : 각 자릿수의 값이 모두 1인 수에서 해당 2진수를 뺀 수
//							   쉽게 말해 합쳐서 1111 1111이 되는 수
		// 
//						10진수	---->	2진수
//						5		---->	0000 0101  
		
		// Ex) 5에 대한 1의 보수를 구하는 법
//						1111 1111				--> 모두가 1인 수
//					-	0000 0101				--> 해당 2진수
		// --------------------------------------------------------
//			    	    1111 1010				--> 5에 대한 1의 보수 == -127 + 64 + 32 + 16 + 8 + 0 + 2 + 0 == -5
//						1111 1011				--> 5에 대한 2의 보수 == -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 == -5
						
		
		
		
		// 2) 1의 보수를 간단하게 구하는 법
		// 
		// 해당 2진수를 반전시키면 1의 보수다
//				10진수	---->	2진수
		// Ex)	5		---->	101  
//			--------------------------------
		// 10진수 5에 대한 1의 보수는 010
		
		
		
		
		
		// 3) 2의 보수 구하는 법
		// 
		// 1의 보수에서 1을 더한 값과 같다.
		// 
		// // 자리 올림이 생기면 앞에 있는 비트를 삭제 ==> 000
		// 즉 결과값이 0이 됨.
		// 
		// 
		// 
		// 
		// 
		// 간단하게 한번보자면,
		// 10진수 5에 대한 2의 보수는 011

		// 즉 5		-		5
		// --------------------------
		// 101		+		5에 대한 2의 보수 (011) ==> 1000 
		
		
		
		// 5 - 5 = 0
				// 
		// 5라는 10진수를 2진수로 변환하면
		// 0	0	0	0	0	1	0	1		  == 5
		// 1	1	1	1	1	0	1	0		  == 5에 대한 1의 보수 (비트를 반전시킨 것과 결과가 동일)
		// 1	1	1	1	1	0	1	1		  == 5에 대한 2의 보수 (2의 보수는 1의 보수에서 1을 더한 값과 동일)
//															 5와 5에 대한 2의 보수의 합 == 0
		//--------------------------------------------------------(+)
		// 1	0	0	0	0	0	0	0	0	  앞에 있는 1을 없애버리면서 
//				0	0	0	0	0	0	0	0	  결과가 이렇게 0이 됨.
		
		
		// -5에 대한 이진 데이터를 10진수로 변환하는 과정
		// 1	1	1	1	1	0	1	1		  == 5에 대한 2의 보수 == -5
		// -128	64	32	16	8	4	2	1
		//------------- 각각 곱하기 후 더하기 ------------------------------
		// -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 == -5
		
		
		
		
		// 문제) 각 10진수를 2진수로 변환 후에 1의보수와 2의 보수를 구해보자 !!!

		//  10		->		0000 0000 (이진수)
		//	  		->		0000 0000 (1의보수)
		//				   +0000 0001
		//--------------------------
		// -10				0000 0000 (2의보수)
		// 
		// 
		//
		// 8		->		0000 0000 (이진수)
		//			    	0000 0000 (1의보수)
		//			       +0000 0001 
		//	--------------------------
		// -8		->		0000 0000 (2의보수)
		// 
	
		//  20		->		0000 0000 (이진수)
		//			->		0000 0000 (1의보수)
		//				   +0000 0001
		//--------------------------
		// -20				0000 0000 (2의보수)
		// 
		// 
		//
		// 120		->		0000 0000 (이진수)
		//			    	0000 0000 (1의보수)
		//			       +0000 0001 
		//	--------------------------
		// -120		->		0000 0000 (2의보수)
	
	
		//  97		->		0000 0000 (이진수)
		//			->		0000 0000 (1의보수)
		//				   +0000 0001
		//--------------------------
		// -97				0000 0000 (2의보수)
		// 
		// 
		//
		// 42		->		0000 0000 (이진수)
		//			    	0000 0000 (1의보수)
		//		  	       +0000 0001 
		//	--------------------------
		// -42		->		0000 0000 (2의보수)
		
		
		
		
		
		
		
		
		
		
		
		// 해답)
		
			//  10		->		0000 1010 (이진수)
		//	  		->		1111 0101 (1의보수)
		//					   +0000 0001
			//--------------------------
			// -10				1111 0110 (2의보수)
			// 
			// 
			//
			// 8		->		0000 1000 (이진수)
		//				    	1111 0111 (1의보수)
		//				       +0000 0001 
		//		--------------------------
			// -8		->		1111 1000 (2의보수)
			// 
		
			//  20		->		0001 0100 (이진수)
		//	  		->			1110 1011 (1의보수)
		//					   +0000 0001
			//--------------------------
			// -20				1110 1100 (2의보수)
			// 
			// 
			//
			// 120		->		0111 1000 (이진수)
		//				    	1000 0111 (1의보수)
		//				       +0000 0001 
		//		--------------------------
			// -120		->		1000 1000 (2의보수)
		
		
			//  97		->		0110 0001 (이진수)
		//	  		->			1001 1110 (1의보수)
		//					   +0000 0001
			//--------------------------
			// -97				1001 1111 (2의보수)
			// 
			// 
			//
			// 42		->		0010 1010 (이진수)
		//				    	1101 0101 (1의보수)
		//				       +0000 0001 
		//		--------------------------
			// -42		->		1101 0110 (2의보수)

			
		

		
		
		
		
		
		
		
		

	}

}
